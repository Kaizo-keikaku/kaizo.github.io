<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>作品試し読み | 海象計画</title>
    <link rel="stylesheet" href="style2.css">
    <link href="https://fonts.googleapis.com/css2?family=Zen+Old+Mincho:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <a href="index.html" class="back-home">← 戻る</a>
    
    <div class="viewer">
        <div id="bubble-container"></div>
        <article class="content" id="main-content">
            <p>読み込み中...</p>
        </article>
    </div>

    <script>
        const viewer = document.querySelector('.viewer');
        const contentArea = document.getElementById('main-content');
        const bubbleContainer = document.getElementById('bubble-container');
        
        // 1. マウスホイール制御（縦スクロールで横に移動）
        viewer.addEventListener('wheel', (e) => {
            if (e.deltaY !== 0) {
                e.preventDefault();
                viewer.scrollBy({
                    left: -e.deltaY * 1.5, // 少し加速
                    behavior: 'auto'
                });
            }
        }, { passive: false });

        // 2. 泡の生成
        function createBubbles() {
            // コンテンツの幅に合わせて泡を散らす
            const width = Math.max(viewer.scrollWidth, window.innerWidth);
            for (let i = 0; i < 50; i++) {
                const bubble = document.createElement('div');
                bubble.className = 'bubble';
                const size = Math.random() * 15 + 5 + 'px';
                bubble.style.width = size;
                bubble.style.height = size;
                bubble.style.left = Math.random() * width + 'px';
                bubble.style.animationDelay = Math.random() * 10 + 's';
                bubble.style.opacity = Math.random() * 0.5;
                bubbleContainer.appendChild(bubble);
            }
        }
        /* --- sample.html の <script> 内を以下に差し替え --- */

// 3. テキスト読み込みと色制御
async function loadText() {
    const params = new URLSearchParams(window.location.search);
    const workId = params.get('work');
    if (!workId) {
        contentArea.innerHTML = '<h2>エラー</h2><p>作品が指定されていません。</p>';
        return;
    }
    const formattedId = workId.padStart(2, '0');
    const fileName = `work_${formattedId}.txt`;

    try {
        const response = await fetch(fileName);
        if (!response.ok) throw new Error('File not found');
        const text = await response.text();

        const lines = text.split(/\r?\n/);
        const htmlElements = lines.map(line => {
            const trimmedLine = line.trim();
            if (!trimmedLine) return '';
            const titleMatch = trimmedLine.match(/^＜＜(.+)＞＞$/);
            if (titleMatch) {
                return `<h2>${titleMatch[1]}</h2>`;
            } else {
                return `<p>${trimmedLine}</p>`;
            }
        }).join('');

        contentArea.innerHTML = htmlElements;

// --- 文字色切り替えロジック ---
// --- 文字色切り替えロジック ---
        const backBtn = document.querySelector('.back-home');
        
        viewer.addEventListener('scroll', () => {
            const scrollWidth = viewer.scrollWidth;
            const clientWidth = viewer.clientWidth;
            const scrollLeft = viewer.scrollLeft;
            
            // スクロール可能な最大量
            const maxScroll = scrollWidth - clientWidth;
            
            // 【修正】ブラウザごとのRTL挙動の差を正規化して「右端からの移動距離」を計算
            let distanceFromRight;
            
            if (scrollLeft > 0) {
                // Safari系: 初期値が maxScroll で、左にスクロールすると 0 に向かう
                distanceFromRight = maxScroll - scrollLeft;
            } else {
                // Chrome系: 初期値が 0 で、左にスクロールするとマイナスに向かう
                distanceFromRight = Math.abs(scrollLeft);
            }
            
            // コンテンツ全体の30%を閾値に設定
            const threshold = scrollWidth * 0.3;
            
            // 判定
            if (distanceFromRight > threshold) {
                contentArea.classList.add('deep-sea-text');
                backBtn.classList.add('white-mode');
            } else {
                contentArea.classList.remove('deep-sea-text');
                backBtn.classList.remove('white-mode');
            }
        });

        setTimeout(createBubbles, 100);

    } catch (error) {
        contentArea.innerHTML = `<h2>エラー</h2><p>作品が見つかりませんでした。</p>`;
    }
}

loadText();
    </script>
</body>
</html>