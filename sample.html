<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>海象 第1号 試し読み</title>
    <!-- メインのスタイルシート (フォント設定など) -->
    <link rel="stylesheet" href="style.css">
    <!-- 試し読みページ専用の縦書き・全画面スタイルシート -->
    <link rel="stylesheet" href="style2.css">
</head>
<body class="sample-page">

    <header class="sample-header">
        <a href="index.html" class="back-link">
            <span class="arrow">←</span> 
            トップへ戻る
        </a>
        <h1>海象 第1号 試し読み</h1>
        <p class="sample-spec" style="visibility: hidden;">ダミー</p> <!-- レイアウト調整用 -->
    </header>

    <!-- ページングを制御するメインコンテナ -->
    <div id="readingContainer" class="reading-container">
        <!-- ページ分割されたコンテンツがここに追加されます -->
    </div>

    <!-- ナビゲーションボタン -->
    <div class="nav-buttons">
        <!-- 縦書きなので右のボタンが「次へ」 -->
        <button id="prevBtn" class="nav-button left-btn" disabled>
            &#10094;
        </button>
        <button id="nextBtn" class="nav-button right-btn">
            &#10095;
        </button>
    </div>

    <!-- 元のテキストを保持する要素 (ページ分割後に削除または非表示) -->
    <div id="rawText" style="display: none;">
        <p class="author">著者名：潮見</p>
        <h2 class="section-title">水面を叩くもの（抜粋）</h2>

        <!-- テキストコンテンツ（約2000字程度の試し読みテキストをここに入力） -->
        街はつい先刻まで、白い光の中に浮いていた。鏡張りの水面が生み出すもう一つの太陽と、ひとりでに煌めく化粧漆喰の壁たち。そこかしこに在る恒星が、輪郭の無い世界...
        <!-- ここに添付ファイルから取得した約2000字のテキストを流し込みます -->
        街はつい先刻まで、白い光の中に浮いていた。鏡張りの水面が生み出すもう一つの太陽と、ひとりでに煌めく化粧漆喰の壁たち。そこかしこに在る恒星が、輪郭の無い世界に散らばっている。その光の粒子が目に入り、私は幾度か目を細めた。しかし、それは決して不快な眩しさではなかった。むしろ、街全体が深い眠りに入り、その夢が結晶化して、透明な泡となって昇っていくのを、私自身が感じられるような心地よさがあった。
        その時、街の空気が一変した。太陽が、本来あるべき位置へと静かに戻ったのだ。鏡像の太陽はゆっくりと水面に消え、化粧漆喰の壁の輝きも落ち着きを取り戻した。泡は弾け、深い眠りは覚めて、日常の喧騒が戻ってくる。私は、あの束の間の静寂の中で、まるで魂を抜き取られたような気分になっていた。
        
        この場所は、ヴェネツィアだった。私は映画祭のメインホールに座っていた。会場の照明がゆっくりと落ちていく。そして、私の魂は暗闇の中で、再びその肉体へと戻った。
        
        上映されたのは、巨匠・蔵前良一の遺作、『黒い波』だった。映画は、終映を迎えた。五秒、十秒...会場全体が息を潜めた後、息を、その場にいた全員が深く息を吸い込んだ。その反動からか、次の瞬間、暴風雨のようなアプローズが起こった。私はひとり、重力に逆らうことができずに、座席に沈んでいた。あのような熱狂を見上げることは、もうできないであろう。それが、蔵前良一の死が意味することだった。
        だが、この世紀の傑作が公式に上映されたのは、一度きりだった。
        「蔵前良一、ヴェネツィアで七分超のスタンディングオベーションを受ける」
        この見出しこそ日本にも届いたが、次に話題を攫ったのは、この映画を「いかなる劇場においても公開しない」とする映倫、他当局の共同声明だった。「風紀の乱れを危惧しての事」と短く理由が添えられた。あれが、最後の作品になってしまった。偉大な監督の遺作だが、それを見ることができたのは、あの時メインホールに集まった一〇〇〇人強だけだった。
        モネの描いた、燃えるような黄昏の中を帰るとき、私は幾度か道行く人に話しかけられた。その大半が日本人でも、映画祭の関係者でもなかった。励ます者、敬意を示す者、共に嘆こうとする者。彼らの表現は皆違っていたが、見知らぬ者に口を開いた、その原動力は同じなのだろう。水際から離れる方向に折れて、ようやく一人になった。矢先に見た眺めを「夕焼けが作り出す街の景色が悲しい」とはこんな感じだろうかと、思い出す。そんな風に言う人を知っているのだ。正確には、そんな風に書かれた文章を知っている。私は夕焼けが作り出す街の景色が悲しい、という言葉を知っている。
        
        それは、蔵前良一の映画を愛する人々が作り上げたウェブサイトの掲示板に、誰かが残した言葉だった。彼らのウェブサイトは、公式な声明が出た後、わずか数時間で閉鎖された。その理由も、誰にも知らされなかった。蔵前良一の死、映画の公開中止、そしてファンサイトの閉鎖。全てが同時に起こった。それは、まるで巨大な波が全てを飲み込んでいったかのようだった。
        私は立ち止まり、運河のきらめきを見た。それは、最初に見た鏡像の太陽を思い出させた。そして、その光が私に一つの確信を与えた。蔵前良一は、この映画を通じて、私たちに何かを伝えようとしていた。それは、言葉や映像だけでは伝えられない、何か深い、海のような感情だった。
        私は彼の映画を再び見たい。その思いが、私をこの旅へと駆り立てている。
        
        この街は、私にとって、蔵前良一の残した最後の痕跡だ。そして、私は、その痕跡を辿り、彼の魂の深海へと潜り込んでいく。
        
        私は、今、黒い波の岸辺に立っている。その波は、私をどこへ連れて行くのだろうか。
        <!-- テキストここまで -->
    </div>

    <script>
        // DOM要素の取得
        const readingContainer = document.getElementById('readingContainer');
        const rawTextContainer = document.getElementById('rawText');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        let currentPage = 0;
        let totalPages = 0;

        /**
         * 与えられた生のテキストを動的にページに分割し、DOMに挿入する
         */
        function paginateText() {
            // 既存のページをクリア
            readingContainer.innerHTML = '';
            
            // rawTextの内容を取得し、構造要素と純粋なテキストに分ける
            // (今回はシンプルに全てのテキストノードを結合して処理します)
            const rawHtml = rawTextContainer.innerHTML;
            const fullText = rawTextContainer.textContent.trim();
            let remainingText = fullText;
            
            const textNodes = [];
            // <p class="author">著者名：潮見</p>
            const authorTag = rawTextContainer.querySelector('.author');
            if (authorTag) textNodes.push({ type: 'header', content: authorTag.outerHTML });
            
            // <h2 class="section-title">水面を叩くもの（抜粋）</h2>
            const titleTag = rawTextContainer.querySelector('.section-title');
            if (titleTag) textNodes.push({ type: 'header', content: titleTag.outerHTML });

            // 段落ごとに分割
            const rawParagraphs = fullText.split('\n').map(p => p.trim()).filter(p => p.length > 0);
            rawParagraphs.forEach(p => textNodes.push({ type: 'paragraph', content: p }));

            let currentTextIndex = 0;
            let pageIndex = 0;

            // ページングを繰り返す
            while (currentTextIndex < textNodes.length) {
                const page = document.createElement('div');
                page.classList.add('page');
                
                // ページ計測用に一時的に挿入
                readingContainer.appendChild(page);

                // --- 1. ヘッダー情報の追加 ---
                if (pageIndex === 0) {
                    // 最初のページにのみタイトルと著者名を追加
                    const headerContent = textNodes.filter(node => node.type === 'header').map(node => node.content).join('');
                    page.innerHTML = headerContent;
                    currentTextIndex = textNodes.findIndex(node => node.type === 'paragraph');
                    if (currentTextIndex === -1) currentTextIndex = textNodes.length; // 段落がなければ終了
                } else {
                    // 2ページ目以降は段落から開始
                    currentTextIndex = textNodes.findIndex(node => node.type === 'paragraph' && textNodes.indexOf(node) >= currentTextIndex);
                    if (currentTextIndex === -1) break; // すでに全段落を処理済みなら終了
                }

                // --- 2. 段落ごとのテキストフロー処理 ---
                let contentFits = true;
                let currentContent = page.innerHTML; // 既にヘッダーがあれば保持
                
                // 段落が残っている限り処理
                while (currentTextIndex < textNodes.length) {
                    const node = textNodes[currentTextIndex];
                    if (node.type !== 'paragraph') {
                        currentTextIndex++;
                        continue;
                    }
                    
                    let pTag = `<p>${node.content}</p>`;
                    
                    // 新しい内容を試す
                    page.innerHTML = currentContent + pTag;

                    // オーバーフローチェック (縦書きでは scrollWidth > clientWidth でチェック)
                    const isOverflowing = page.scrollWidth > page.clientWidth;

                    if (!isOverflowing) {
                        // 収まる場合：コンテンツを確定し、次の段落へ進む
                        currentContent = page.innerHTML;
                        currentTextIndex++; 
                    } else {
                        // 収まらない場合：この段落を文字単位で分割し、残りを次のページへ送る
                        page.innerHTML = currentContent; // 収まったところまでを復元

                        // 文字単位で収まるまで削るロジックをここで実行 (簡略化のため、この段落全体を次のページに送ります)
                        // 厳密な文字分割は計算コストが高いため、ここでは「段落」を最小の分割単位とします。
                        if (pageIndex === 0 && page.innerHTML === headerContent) {
                            // ヘッダーしか入らない場合、最小の段落でも収まらない可能性があるが、ここでは段落単位で送る
                        }

                        // この段落は次のページへ送るため、ループを抜けて次のページを作成
                        contentFits = false;
                        break; 
                    }
                }

                // ループが終了した場合、これが最後のページ
                if (contentFits) {
                    totalPages = pageIndex + 1;
                    break;
                }
                
                pageIndex++;
            }
            
            // ページ分割後の最終チェックと読了メッセージの追加
            if (totalPages > 0) {
                // 読了メッセージ用のページを追加
                const endPage = document.createElement('div');
                endPage.classList.add('end-message');
                endPage.innerHTML = '<h2>読了</h2><p>この続きは、海象 第1号でお楽しみください。</p><a href="index.html" class="back-link" style="margin-top: 20px; font-size: 1.2rem; opacity: 1;">トップページに戻る</a>';
                readingContainer.appendChild(endPage);
                totalPages++; // 読了ページも含む

                // 初期状態をリセットして、ページネーションとボタンを更新
                currentPage = 0;
                updateNavigation();
                // 最初のページにスクロール位置を設定
                readingContainer.scrollLeft = readingContainer.scrollWidth;
            }
        }

        /**
         * 現在のページとボタンの状態を更新する
         */
        function updateNavigation() {
            // スクロール位置の更新
            const pageOffset = currentPage * readingContainer.clientWidth;
            // 縦書き（右から左）なので、最大スクロール位置から逆算してスクロール位置を決定
            // scrollWidth - clientWidth が最大スクロール量
            const scrollMax = readingContainer.scrollWidth - readingContainer.clientWidth;
            const targetScrollLeft = scrollMax - pageOffset;
            
            // 'smooth' scroll-behavior は CSSで設定済み
            readingContainer.scrollLeft = targetScrollLeft;

            // ボタンの有効/無効
            prevBtn.disabled = currentPage === totalPages - 1; // 最後のページ（一番左）で無効
            nextBtn.disabled = currentPage === 0;              // 最初のページ（一番右）で無効
            
            // 最終ページでメッセージ表示
            if (currentPage === totalPages - 1) {
                console.log("最終ページです。");
            }
        }
        
        /**
         * 次のページへ進む（横書きでは左へスクロール）
         */
        function nextPage() {
            if (currentPage < totalPages - 1) {
                currentPage++;
                updateNavigation();
            }
        }

        /**
         * 前のページへ戻る（横書きでは右へスクロール）
         */
        function prevPage() {
            if (currentPage > 0) {
                currentPage--;
                updateNavigation();
            }
        }
        
        // --- イベントリスナーの設定 ---
        nextBtn.addEventListener('click', nextPage);
        prevBtn.addEventListener('click', prevPage);
        
        // キーボード操作 (左右キーでページ送り)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight') { // 右キーで次ページ (縦書きでは右へ移動 = 前のページ)
                prevPage(); 
            } else if (e.key === 'ArrowLeft') { // 左キーで前ページ (縦書きでは左へ移動 = 次のページ)
                nextPage(); 
            }
        });

        // 画面サイズ変更時の再ページ分割
        window.addEventListener('resize', () => {
            paginateText();
        });

        // 初期化
        window.onload = function() {
            // テキスト分割と初期表示
            paginateText();
        }

    </script>
</body>
</html>

